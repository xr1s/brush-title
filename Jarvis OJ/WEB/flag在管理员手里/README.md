# flag在管理员手里

这根本就不是Web题，这完全算是Crypto好不好……属于Web的顶多只能算是一开始的找一个莫名其妙的vim恢复文件。

算是比较蛋疼的一题，其实要是用工具（`hash_extender`，可以在github找到）的话，这题是秒出的。

但丧心病狂的是，我为了加深理解手写了一遍长度扩展攻击（MD5主体用了openssl的实现）。

更丧心病狂的是，我不仅用C手写了MD5长度扩展攻击，还手写了一遍网络请求。

最丧心病狂的是，因为不知道盐的长度需要爆破，本着能优化则优化的态度，我去写了个epoll处理多个socket。

然后……调了好久，最后心态爆炸懒得写了，乱写了一个简单粗暴的`jarvis_send`函数用来拼接字符串发送请求。

吐槽完了，来说说哈希长度扩展攻击的套路。令接下去文中`+`为字符串连接操作。

## Hash Length Extension Attack

对于一个`MD5(secret + data)`，如果我们知道`secret`的长度，`data`是可控的，我们就可以在不知道`secret`具体是什么的情况下解出`MD5(secret + data + padding + whatever)`，其中，`data`, `padding`和`whatever`都属于用户输入，也就是新的`data`。除了`padding`是由前两者的长度确定的不可变的，`whatever`可以是任意字符串。

因为MD5是分块加密算法，所以在遇到加密的字符串不足长的时候需要往后填充字符，使之恰好和一块一样长。对于MD5而言，增添的规则

1. 如果字节数恰好模64余56，跳到第三步。
2. 首先填一个`\x80`，然后往后填`\x00`到字节数模64余56。
3. 剩下8字节填充**原字节数**以小端序二进制表达。

就恰好64字节一块可以分完了。这之后进行加密，为了保证计算同一串字符的MD5无论什么条件下都始终相等，标准(RFC 1321)预定义了MD5的初始化向量。然后对于每个64字节的块进行一次加密后，向量都会改变，改变后的向量将作为下一块的初始化向量继续计算。这就带来了一个问题，攻击者在知道了一串MD5和输入字符串的长度之后，可以自行构造padding使它恰好进入下一轮计算，也就相当于得知了下一组的初始化向量。而知道了初始化向量，输入（这里的输入对应上方的`whatever`）是完全可控的，这样下一组计算的过程对攻击者而言是完全透明的。

Hash长度扩展攻击就利用了这个特性。

这题稍微难一点点，加了个reverse。
