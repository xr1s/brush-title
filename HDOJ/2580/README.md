# A simple stone game

K 倍动态减法模板题, 不要看论文, 论文复杂度不够.

总之打表找规律. 关于分析的话, 说服力不足, 明显的从结论逆推, 缺乏证明的感觉.

大概可以这么考虑:

已知 k=1 时 P-Position 为 2 的幂次, N-Position 策略为取走当前石子个数二进制编码中的最小的那个 1 表示的数; k=2 时 P-Position 为斐波那契数, N-Position 策略为取走当前石子个数[斐波那契编码](https://en.wikipedia.org/wiki/Fibonacci_coding)中最小的那个 1 表示的数.

思考为什么能成功, 原因是 N-Position 取走最低位的 1, 每次对方只能取走一个 k 倍以内的数使得低位多出了 1, 但是先手每次都可以做到把 1 去掉, 于是最后一个 1 总是被先手取走, 所以先手总是能取成 0, 必胜. 换句话说, 在 N-Position 的总是消去对应编码下的 1, 而 P-Position 的总是创造对应编码下的 1. 因此必胜.

所以不同的 k 实际上对应不同的编码, 每个编码对应一个数列, 实际上是 P-Position 组成的数列. 为了保证 P-Position 选手生产出多个 1 之后我们可以把它生产出来的最小的 1 去掉 (这部分的证明和数列性质有关, 我不会), 应该使数列满足 p[m+1]=p[m]+p[j], 其中 j=1+max{i|p[i]\*k\<p[m]}, 这保证了 p[j]\*k\>=p[m].

于是我们只需要随着 m 的递增维护这个 max{i|p[i]\*k\<=p[m-1]}, 就可以做到 O(log n) 级别求出整个数列 (这个数列是指数增长的, 虽然在 k 较大的时候底数较小), 总复杂度就是 O(log n).
