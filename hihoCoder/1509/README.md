# XOR Sorting

给出一个数列，问在0..1 << 60里有多少个S能使得整个数列xor S之后保证非减。

这题我的思路非常简单粗暴，从高位到低位按照连续的01分块，如果同为0和同为1的块数量比2多，这样不论如何异或都无法保证递增，这一位肯定有多余的翻转，也就是总会有一个先增后降或先降后增的过程。

然后对于一个递归处理的块bit位，如果只有0或者只有1，那显然S在这一位取0或者1都可以。如果有两块，那S在这一层就只能有一个。

然后对于每一块递归下去就好了。

这题唯一被坑的点是(int) << (long long)的结果是(int)。算是学到了。
